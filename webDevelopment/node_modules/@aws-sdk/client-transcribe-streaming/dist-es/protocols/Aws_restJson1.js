import { _json, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectLong as __expectLong, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseBoolean as __parseBoolean, strictParseInt32 as __strictParseInt32, take, withBaseException, } from "@aws-sdk/smithy-client";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { AudioStream, BadRequestException, ConflictException, InternalFailureException, LimitExceededException, ServiceUnavailableException, } from "../models/models_0";
import { TranscribeStreamingServiceException as __BaseException } from "../models/TranscribeStreamingServiceException";
export const se_StartCallAnalyticsStreamTranscriptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-transcribe-language-code": input.LanguageCode,
        "x-amzn-transcribe-sample-rate": [
            () => isSerializableHeaderValue(input.MediaSampleRateHertz),
            () => input.MediaSampleRateHertz.toString(),
        ],
        "x-amzn-transcribe-media-encoding": input.MediaEncoding,
        "x-amzn-transcribe-vocabulary-name": input.VocabularyName,
        "x-amzn-transcribe-session-id": input.SessionId,
        "x-amzn-transcribe-vocabulary-filter-name": input.VocabularyFilterName,
        "x-amzn-transcribe-vocabulary-filter-method": input.VocabularyFilterMethod,
        "x-amzn-transcribe-language-model-name": input.LanguageModelName,
        "x-amzn-transcribe-enable-partial-results-stabilization": [
            () => isSerializableHeaderValue(input.EnablePartialResultsStabilization),
            () => input.EnablePartialResultsStabilization.toString(),
        ],
        "x-amzn-transcribe-partial-results-stability": input.PartialResultsStability,
        "x-amzn-transcribe-content-identification-type": input.ContentIdentificationType,
        "x-amzn-transcribe-content-redaction-type": input.ContentRedactionType,
        "x-amzn-transcribe-pii-entity-types": input.PiiEntityTypes,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/call-analytics-stream-transcription";
    let body;
    if (input.AudioStream !== undefined) {
        body = se_AudioStream(input.AudioStream, context);
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_StartMedicalStreamTranscriptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-transcribe-language-code": input.LanguageCode,
        "x-amzn-transcribe-sample-rate": [
            () => isSerializableHeaderValue(input.MediaSampleRateHertz),
            () => input.MediaSampleRateHertz.toString(),
        ],
        "x-amzn-transcribe-media-encoding": input.MediaEncoding,
        "x-amzn-transcribe-vocabulary-name": input.VocabularyName,
        "x-amzn-transcribe-specialty": input.Specialty,
        "x-amzn-transcribe-type": input.Type,
        "x-amzn-transcribe-show-speaker-label": [
            () => isSerializableHeaderValue(input.ShowSpeakerLabel),
            () => input.ShowSpeakerLabel.toString(),
        ],
        "x-amzn-transcribe-session-id": input.SessionId,
        "x-amzn-transcribe-enable-channel-identification": [
            () => isSerializableHeaderValue(input.EnableChannelIdentification),
            () => input.EnableChannelIdentification.toString(),
        ],
        "x-amzn-transcribe-number-of-channels": [
            () => isSerializableHeaderValue(input.NumberOfChannels),
            () => input.NumberOfChannels.toString(),
        ],
        "x-amzn-transcribe-content-identification-type": input.ContentIdentificationType,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/medical-stream-transcription";
    let body;
    if (input.AudioStream !== undefined) {
        body = se_AudioStream(input.AudioStream, context);
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_StartStreamTranscriptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-transcribe-language-code": input.LanguageCode,
        "x-amzn-transcribe-sample-rate": [
            () => isSerializableHeaderValue(input.MediaSampleRateHertz),
            () => input.MediaSampleRateHertz.toString(),
        ],
        "x-amzn-transcribe-media-encoding": input.MediaEncoding,
        "x-amzn-transcribe-vocabulary-name": input.VocabularyName,
        "x-amzn-transcribe-session-id": input.SessionId,
        "x-amzn-transcribe-vocabulary-filter-name": input.VocabularyFilterName,
        "x-amzn-transcribe-vocabulary-filter-method": input.VocabularyFilterMethod,
        "x-amzn-transcribe-show-speaker-label": [
            () => isSerializableHeaderValue(input.ShowSpeakerLabel),
            () => input.ShowSpeakerLabel.toString(),
        ],
        "x-amzn-transcribe-enable-channel-identification": [
            () => isSerializableHeaderValue(input.EnableChannelIdentification),
            () => input.EnableChannelIdentification.toString(),
        ],
        "x-amzn-transcribe-number-of-channels": [
            () => isSerializableHeaderValue(input.NumberOfChannels),
            () => input.NumberOfChannels.toString(),
        ],
        "x-amzn-transcribe-enable-partial-results-stabilization": [
            () => isSerializableHeaderValue(input.EnablePartialResultsStabilization),
            () => input.EnablePartialResultsStabilization.toString(),
        ],
        "x-amzn-transcribe-partial-results-stability": input.PartialResultsStability,
        "x-amzn-transcribe-content-identification-type": input.ContentIdentificationType,
        "x-amzn-transcribe-content-redaction-type": input.ContentRedactionType,
        "x-amzn-transcribe-pii-entity-types": input.PiiEntityTypes,
        "x-amzn-transcribe-language-model-name": input.LanguageModelName,
        "x-amzn-transcribe-identify-language": [
            () => isSerializableHeaderValue(input.IdentifyLanguage),
            () => input.IdentifyLanguage.toString(),
        ],
        "x-amzn-transcribe-language-options": input.LanguageOptions,
        "x-amzn-transcribe-preferred-language": input.PreferredLanguage,
        "x-amzn-transcribe-vocabulary-names": input.VocabularyNames,
        "x-amzn-transcribe-vocabulary-filter-names": input.VocabularyFilterNames,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/stream-transcription";
    let body;
    if (input.AudioStream !== undefined) {
        body = se_AudioStream(input.AudioStream, context);
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_StartCallAnalyticsStreamTranscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartCallAnalyticsStreamTranscriptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        RequestId: [, output.headers["x-amzn-request-id"]],
        LanguageCode: [, output.headers["x-amzn-transcribe-language-code"]],
        MediaSampleRateHertz: [
            () => void 0 !== output.headers["x-amzn-transcribe-sample-rate"],
            () => __strictParseInt32(output.headers["x-amzn-transcribe-sample-rate"]),
        ],
        MediaEncoding: [, output.headers["x-amzn-transcribe-media-encoding"]],
        VocabularyName: [, output.headers["x-amzn-transcribe-vocabulary-name"]],
        SessionId: [, output.headers["x-amzn-transcribe-session-id"]],
        VocabularyFilterName: [, output.headers["x-amzn-transcribe-vocabulary-filter-name"]],
        VocabularyFilterMethod: [, output.headers["x-amzn-transcribe-vocabulary-filter-method"]],
        LanguageModelName: [, output.headers["x-amzn-transcribe-language-model-name"]],
        EnablePartialResultsStabilization: [
            () => void 0 !== output.headers["x-amzn-transcribe-enable-partial-results-stabilization"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-enable-partial-results-stabilization"]),
        ],
        PartialResultsStability: [, output.headers["x-amzn-transcribe-partial-results-stability"]],
        ContentIdentificationType: [, output.headers["x-amzn-transcribe-content-identification-type"]],
        ContentRedactionType: [, output.headers["x-amzn-transcribe-content-redaction-type"]],
        PiiEntityTypes: [, output.headers["x-amzn-transcribe-pii-entity-types"]],
    });
    const data = output.body;
    contents.CallAnalyticsTranscriptResultStream = de_CallAnalyticsTranscriptResultStream(data, context);
    return contents;
};
const de_StartCallAnalyticsStreamTranscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribestreaming#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.transcribestreaming#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.transcribestreaming#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.transcribestreaming#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.transcribestreaming#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartMedicalStreamTranscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartMedicalStreamTranscriptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        RequestId: [, output.headers["x-amzn-request-id"]],
        LanguageCode: [, output.headers["x-amzn-transcribe-language-code"]],
        MediaSampleRateHertz: [
            () => void 0 !== output.headers["x-amzn-transcribe-sample-rate"],
            () => __strictParseInt32(output.headers["x-amzn-transcribe-sample-rate"]),
        ],
        MediaEncoding: [, output.headers["x-amzn-transcribe-media-encoding"]],
        VocabularyName: [, output.headers["x-amzn-transcribe-vocabulary-name"]],
        Specialty: [, output.headers["x-amzn-transcribe-specialty"]],
        Type: [, output.headers["x-amzn-transcribe-type"]],
        ShowSpeakerLabel: [
            () => void 0 !== output.headers["x-amzn-transcribe-show-speaker-label"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-show-speaker-label"]),
        ],
        SessionId: [, output.headers["x-amzn-transcribe-session-id"]],
        EnableChannelIdentification: [
            () => void 0 !== output.headers["x-amzn-transcribe-enable-channel-identification"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-enable-channel-identification"]),
        ],
        NumberOfChannels: [
            () => void 0 !== output.headers["x-amzn-transcribe-number-of-channels"],
            () => __strictParseInt32(output.headers["x-amzn-transcribe-number-of-channels"]),
        ],
        ContentIdentificationType: [, output.headers["x-amzn-transcribe-content-identification-type"]],
    });
    const data = output.body;
    contents.TranscriptResultStream = de_MedicalTranscriptResultStream(data, context);
    return contents;
};
const de_StartMedicalStreamTranscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribestreaming#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.transcribestreaming#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.transcribestreaming#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.transcribestreaming#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.transcribestreaming#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartStreamTranscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartStreamTranscriptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        RequestId: [, output.headers["x-amzn-request-id"]],
        LanguageCode: [, output.headers["x-amzn-transcribe-language-code"]],
        MediaSampleRateHertz: [
            () => void 0 !== output.headers["x-amzn-transcribe-sample-rate"],
            () => __strictParseInt32(output.headers["x-amzn-transcribe-sample-rate"]),
        ],
        MediaEncoding: [, output.headers["x-amzn-transcribe-media-encoding"]],
        VocabularyName: [, output.headers["x-amzn-transcribe-vocabulary-name"]],
        SessionId: [, output.headers["x-amzn-transcribe-session-id"]],
        VocabularyFilterName: [, output.headers["x-amzn-transcribe-vocabulary-filter-name"]],
        VocabularyFilterMethod: [, output.headers["x-amzn-transcribe-vocabulary-filter-method"]],
        ShowSpeakerLabel: [
            () => void 0 !== output.headers["x-amzn-transcribe-show-speaker-label"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-show-speaker-label"]),
        ],
        EnableChannelIdentification: [
            () => void 0 !== output.headers["x-amzn-transcribe-enable-channel-identification"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-enable-channel-identification"]),
        ],
        NumberOfChannels: [
            () => void 0 !== output.headers["x-amzn-transcribe-number-of-channels"],
            () => __strictParseInt32(output.headers["x-amzn-transcribe-number-of-channels"]),
        ],
        EnablePartialResultsStabilization: [
            () => void 0 !== output.headers["x-amzn-transcribe-enable-partial-results-stabilization"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-enable-partial-results-stabilization"]),
        ],
        PartialResultsStability: [, output.headers["x-amzn-transcribe-partial-results-stability"]],
        ContentIdentificationType: [, output.headers["x-amzn-transcribe-content-identification-type"]],
        ContentRedactionType: [, output.headers["x-amzn-transcribe-content-redaction-type"]],
        PiiEntityTypes: [, output.headers["x-amzn-transcribe-pii-entity-types"]],
        LanguageModelName: [, output.headers["x-amzn-transcribe-language-model-name"]],
        IdentifyLanguage: [
            () => void 0 !== output.headers["x-amzn-transcribe-identify-language"],
            () => __parseBoolean(output.headers["x-amzn-transcribe-identify-language"]),
        ],
        LanguageOptions: [, output.headers["x-amzn-transcribe-language-options"]],
        PreferredLanguage: [, output.headers["x-amzn-transcribe-preferred-language"]],
        VocabularyNames: [, output.headers["x-amzn-transcribe-vocabulary-names"]],
        VocabularyFilterNames: [, output.headers["x-amzn-transcribe-vocabulary-filter-names"]],
    });
    const data = output.body;
    contents.TranscriptResultStream = de_TranscriptResultStream(data, context);
    return contents;
};
const de_StartStreamTranscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribestreaming#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.transcribestreaming#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.transcribestreaming#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.transcribestreaming#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.transcribestreaming#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AudioStream = (input, context) => {
    const eventMarshallingVisitor = (event) => AudioStream.visit(event, {
        AudioEvent: (value) => se_AudioEvent_event(value, context),
        ConfigurationEvent: (value) => se_ConfigurationEvent_event(value, context),
        _: (value) => value,
    });
    return context.eventStreamMarshaller.serialize(input, eventMarshallingVisitor);
};
const se_AudioEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "AudioEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/octet-stream" },
    };
    let body = new Uint8Array();
    if (input.AudioChunk != null) {
        body = input.AudioChunk;
    }
    return { headers, body };
};
const se_ConfigurationEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "ConfigurationEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const de_CallAnalyticsTranscriptResultStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["UtteranceEvent"] != null) {
            return {
                UtteranceEvent: await de_UtteranceEvent_event(event["UtteranceEvent"], context),
            };
        }
        if (event["CategoryEvent"] != null) {
            return {
                CategoryEvent: await de_CategoryEvent_event(event["CategoryEvent"], context),
            };
        }
        if (event["BadRequestException"] != null) {
            return {
                BadRequestException: await de_BadRequestException_event(event["BadRequestException"], context),
            };
        }
        if (event["LimitExceededException"] != null) {
            return {
                LimitExceededException: await de_LimitExceededException_event(event["LimitExceededException"], context),
            };
        }
        if (event["InternalFailureException"] != null) {
            return {
                InternalFailureException: await de_InternalFailureException_event(event["InternalFailureException"], context),
            };
        }
        if (event["ConflictException"] != null) {
            return {
                ConflictException: await de_ConflictException_event(event["ConflictException"], context),
            };
        }
        if (event["ServiceUnavailableException"] != null) {
            return {
                ServiceUnavailableException: await de_ServiceUnavailableException_event(event["ServiceUnavailableException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_MedicalTranscriptResultStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["TranscriptEvent"] != null) {
            return {
                TranscriptEvent: await de_MedicalTranscriptEvent_event(event["TranscriptEvent"], context),
            };
        }
        if (event["BadRequestException"] != null) {
            return {
                BadRequestException: await de_BadRequestException_event(event["BadRequestException"], context),
            };
        }
        if (event["LimitExceededException"] != null) {
            return {
                LimitExceededException: await de_LimitExceededException_event(event["LimitExceededException"], context),
            };
        }
        if (event["InternalFailureException"] != null) {
            return {
                InternalFailureException: await de_InternalFailureException_event(event["InternalFailureException"], context),
            };
        }
        if (event["ConflictException"] != null) {
            return {
                ConflictException: await de_ConflictException_event(event["ConflictException"], context),
            };
        }
        if (event["ServiceUnavailableException"] != null) {
            return {
                ServiceUnavailableException: await de_ServiceUnavailableException_event(event["ServiceUnavailableException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_TranscriptResultStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["TranscriptEvent"] != null) {
            return {
                TranscriptEvent: await de_TranscriptEvent_event(event["TranscriptEvent"], context),
            };
        }
        if (event["BadRequestException"] != null) {
            return {
                BadRequestException: await de_BadRequestException_event(event["BadRequestException"], context),
            };
        }
        if (event["LimitExceededException"] != null) {
            return {
                LimitExceededException: await de_LimitExceededException_event(event["LimitExceededException"], context),
            };
        }
        if (event["InternalFailureException"] != null) {
            return {
                InternalFailureException: await de_InternalFailureException_event(event["InternalFailureException"], context),
            };
        }
        if (event["ConflictException"] != null) {
            return {
                ConflictException: await de_ConflictException_event(event["ConflictException"], context),
            };
        }
        if (event["ServiceUnavailableException"] != null) {
            return {
                ServiceUnavailableException: await de_ServiceUnavailableException_event(event["ServiceUnavailableException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_BadRequestException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_BadRequestExceptionRes(parsedOutput, context);
};
const de_CategoryEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ConflictException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ConflictExceptionRes(parsedOutput, context);
};
const de_InternalFailureException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_InternalFailureExceptionRes(parsedOutput, context);
};
const de_LimitExceededException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_LimitExceededExceptionRes(parsedOutput, context);
};
const de_MedicalTranscriptEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_MedicalTranscriptEvent(data, context));
    return contents;
};
const de_ServiceUnavailableException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ServiceUnavailableExceptionRes(parsedOutput, context);
};
const de_TranscriptEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_TranscriptEvent(data, context));
    return contents;
};
const de_UtteranceEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_UtteranceEvent(data, context));
    return contents;
};
const de_Alternative = (output, context) => {
    return take(output, {
        Entities: (_) => de_EntityList(_, context),
        Items: (_) => de_ItemList(_, context),
        Transcript: __expectString,
    });
};
const de_AlternativeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Alternative(entry, context);
    });
    return retVal;
};
const de_CallAnalyticsEntity = (output, context) => {
    return take(output, {
        BeginOffsetMillis: __expectLong,
        Category: __expectString,
        Confidence: __limitedParseDouble,
        Content: __expectString,
        EndOffsetMillis: __expectLong,
        Type: __expectString,
    });
};
const de_CallAnalyticsEntityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CallAnalyticsEntity(entry, context);
    });
    return retVal;
};
const de_CallAnalyticsItem = (output, context) => {
    return take(output, {
        BeginOffsetMillis: __expectLong,
        Confidence: __limitedParseDouble,
        Content: __expectString,
        EndOffsetMillis: __expectLong,
        Stable: __expectBoolean,
        Type: __expectString,
        VocabularyFilterMatch: __expectBoolean,
    });
};
const de_CallAnalyticsItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CallAnalyticsItem(entry, context);
    });
    return retVal;
};
const de_Entity = (output, context) => {
    return take(output, {
        Category: __expectString,
        Confidence: __limitedParseDouble,
        Content: __expectString,
        EndTime: __limitedParseDouble,
        StartTime: __limitedParseDouble,
        Type: __expectString,
    });
};
const de_EntityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Entity(entry, context);
    });
    return retVal;
};
const de_Item = (output, context) => {
    return take(output, {
        Confidence: __limitedParseDouble,
        Content: __expectString,
        EndTime: __limitedParseDouble,
        Speaker: __expectString,
        Stable: __expectBoolean,
        StartTime: __limitedParseDouble,
        Type: __expectString,
        VocabularyFilterMatch: __expectBoolean,
    });
};
const de_ItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Item(entry, context);
    });
    return retVal;
};
const de_LanguageIdentification = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LanguageWithScore(entry, context);
    });
    return retVal;
};
const de_LanguageWithScore = (output, context) => {
    return take(output, {
        LanguageCode: __expectString,
        Score: __limitedParseDouble,
    });
};
const de_MedicalAlternative = (output, context) => {
    return take(output, {
        Entities: (_) => de_MedicalEntityList(_, context),
        Items: (_) => de_MedicalItemList(_, context),
        Transcript: __expectString,
    });
};
const de_MedicalAlternativeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MedicalAlternative(entry, context);
    });
    return retVal;
};
const de_MedicalEntity = (output, context) => {
    return take(output, {
        Category: __expectString,
        Confidence: __limitedParseDouble,
        Content: __expectString,
        EndTime: __limitedParseDouble,
        StartTime: __limitedParseDouble,
    });
};
const de_MedicalEntityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MedicalEntity(entry, context);
    });
    return retVal;
};
const de_MedicalItem = (output, context) => {
    return take(output, {
        Confidence: __limitedParseDouble,
        Content: __expectString,
        EndTime: __limitedParseDouble,
        Speaker: __expectString,
        StartTime: __limitedParseDouble,
        Type: __expectString,
    });
};
const de_MedicalItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MedicalItem(entry, context);
    });
    return retVal;
};
const de_MedicalResult = (output, context) => {
    return take(output, {
        Alternatives: (_) => de_MedicalAlternativeList(_, context),
        ChannelId: __expectString,
        EndTime: __limitedParseDouble,
        IsPartial: __expectBoolean,
        ResultId: __expectString,
        StartTime: __limitedParseDouble,
    });
};
const de_MedicalResultList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MedicalResult(entry, context);
    });
    return retVal;
};
const de_MedicalTranscript = (output, context) => {
    return take(output, {
        Results: (_) => de_MedicalResultList(_, context),
    });
};
const de_MedicalTranscriptEvent = (output, context) => {
    return take(output, {
        Transcript: (_) => de_MedicalTranscript(_, context),
    });
};
const de_Result = (output, context) => {
    return take(output, {
        Alternatives: (_) => de_AlternativeList(_, context),
        ChannelId: __expectString,
        EndTime: __limitedParseDouble,
        IsPartial: __expectBoolean,
        LanguageCode: __expectString,
        LanguageIdentification: (_) => de_LanguageIdentification(_, context),
        ResultId: __expectString,
        StartTime: __limitedParseDouble,
    });
};
const de_ResultList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Result(entry, context);
    });
    return retVal;
};
const de_Transcript = (output, context) => {
    return take(output, {
        Results: (_) => de_ResultList(_, context),
    });
};
const de_TranscriptEvent = (output, context) => {
    return take(output, {
        Transcript: (_) => de_Transcript(_, context),
    });
};
const de_UtteranceEvent = (output, context) => {
    return take(output, {
        BeginOffsetMillis: __expectLong,
        EndOffsetMillis: __expectLong,
        Entities: (_) => de_CallAnalyticsEntityList(_, context),
        IsPartial: __expectBoolean,
        IssuesDetected: _json,
        Items: (_) => de_CallAnalyticsItemList(_, context),
        ParticipantRole: __expectString,
        Sentiment: __expectString,
        Transcript: __expectString,
        UtteranceId: __expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
